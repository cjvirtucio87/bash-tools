#!/usr/bin/env bash

set -e

### A script for setting up vim in a devcontainer.
###
### Essentially, the script builds and starts a container
### with your code and vim configs mounted into its filesystem.
###
### Usage:
###   <Options> vim-devc <Arguments>
###
### Arguments:
###   local_workspace_folder: a (relative or absolute) path
###     to the local workspace folder to be mounted into
###     the container's filesystem
###
### Options:
###   NETWORK: if set to anything, create a network named after
###     this value and remove it when exiting
###
### Remarks:
###   Only Rocky Linux 8 is supported at this time.
###
###   The idea behind this script is similar to what vscode
###   does with devcontainers. It builds and starts a container
###   with your local workspace mounted into its filesystem
###   with a bind mount. However, unlike vscode:
###
###   1. The expectation is to use vim inside the
###     container, not from the host machine.
###   1. Your vim config directories (.vimrc and .vim) are
###     mounted into the container filesystem, as well.
###
###   Moreover, vscode's approach is to start a container
###   with a vscode server running in detached mode, then
###   run docker exec to drop the user into a shell
###   on that container. This script, on the other hand,
###   runs the container in attached mode, directly
###   dropping the user into a shell. As such,
###   the remoteUser and containerUser properties effectively
###   do the same thing, as far as this script is concerned.
###
###   The script relies on your local workspace's
###   devcontainer.json file for configuration. That said,
###   only a few of its properties are currently used:
###
###   1. remoteUser
###   1. containerUser
###
###   If remoteUser is set, the container will be started
###   as that user. If remoteUser is not set, containerUser
###   will be used, instead. If containerUser is not set,
###   the last USER directive of the image's build will
###   be used, instead.

ROOT_DIR="$(dirname "$(readlink --canonicalize "$0")")"
readonly DEV_CONTAINER_NAME='vim-devc'
readonly ROOT_DIR

function build_and_run {
  local local_workspace_folder="$1"
  local_workspace_folder="$(readlink --canonicalize "${local_workspace_folder}")"

  local tag
  tag="$(devcontainer_json "${local_workspace_folder}" 'image')"

  local vim_devc_tag
  vim_devc_tag="$(get_vim_devc_tag "${tag}")"

  build_vim_overlay "${vim_devc_tag}"

  local workspace_name
  workspace_name="$(basename "${local_workspace_folder}")"

  local remote_user
  remote_user="$(get_user "${local_workspace_folder}")"

  local container_workspace_folder="/workspaces/${workspace_name}"

  local run_args=(
    --rm
    --interactive
    --tty
    --entrypoint bash
    --mount "type=bind,src=${local_workspace_folder},dst=${container_workspace_folder}"
    --mount "type=bind,src=${HOME}/.vimrc,dst=/home/dev/.vimrc"
    --mount "type=bind,src=${HOME}/.vim,dst=/home/${remote_user}/.vim"
    --workdir "${container_workspace_folder}"
    --user "${remote_user}"
    --name "${DEV_CONTAINER_NAME}"
  )

  if [[ -v NETWORK ]]; then
    docker network create "${NETWORK}"
    run_args+=(--network "${NETWORK}")
  fi

  docker run "${run_args[@]}" "${vim_devc_tag}"
}

function build_vim_overlay {
  local vim_devc_tag="$1"
  local vim_devc_ctx="${ROOT_DIR}"/../lib/vim_devc/context
  vim_devc_ctx="$(readlink --canonicalize "${vim_devc_ctx}")"

  docker build \
    --tag "${vim_devc_tag}" \
    --file - "${vim_devc_ctx}" \
    <<EOF
FROM ${tag}

USER 0

RUN set -e; \
    dnf install --assumeyes gcc make ncurses ncurses-devel; \
    curl \
      --location \
      --output vim-src.zip \
      https://github.com/vim/vim/archive/refs/heads/master.zip; \
    mkdir vim-src; \
    unzip -d vim-src vim-src.zip; \
    cd vim-src/vim-master; \
    make; \
    make install; \
    vim --version; \
    : ;

USER "\${REMOTE_USER}"
EOF
}

function cleanup {
  >&2 echo "--- starting cleanup ---"
  if [[ -v NETWORK ]]; then
    docker network rm "${NETWORK}" || true
  fi
  >&2 echo "-- done cleanup ---"
}

function devcontainer_json {
  local local_workspace_folder="$1"
  local key="$2"

  local json_path="${local_workspace_folder}/.devcontainer/devcontainer.json"
  if [[ ! -f "${json_path}" ]]; then
    >&2 echo "missing devcontainer.json file in local workspace folder [${local_workspace_folder}]"
    return 1
  fi

  clconf --ignore-env --yaml "${json_path}" getv "${key}"
}

function get_user {
  local local_workspace_folder="$1"

  local user
  if user="$(devcontainer_json "${local_workspace_folder}" 'remoteUser')"; then
    echo -n "${user}"
    return
  fi

  if user="$(devcontainer_json "${local_workspace_folder}" 'containerUser')"; then
    echo -n "${user}"
    return
  fi

  docker image inspect cjvirtucio87/go-devc:rocky8 \
    | clconf --pipe getv 0/Config/User
}

function exec_existing {
  local local_workspace_folder="$1"

  local workspace_name
  workspace_name="$(basename "${local_workspace_folder}")"

  local remote_user
  remote_user="$(get_user "${local_workspace_folder}")"

  local container_workspace_folder="/workspaces/${workspace_name}"

  docker exec \
    --interactive \
    --tty \
    --workdir "${container_workspace_folder}" \
    --user "${remote_user}" \
    "${DEV_CONTAINER_NAME}" bash
}

function get_vim_devc_tag {
  local tag="$1"

  if [[ "${tag}" =~ :[[:alnum:]]$ ]]; then
    local no_version_tag
    no_version_tag="$(echo -n "${tag}" | cut -d ':' -f1)"
    local tag_version
    tag_version="$(echo -n "${tag}" | cut -d ':' -f2)"

    tag="${no_version_tag}-vim-devc:${tag_version}"
  fi

  echo -n "${tag}"
}

function main {
  cleanup
  trap cleanup EXIT

  if docker container inspect "${DEV_CONTAINER_NAME}" &>/dev/null; then
    >&2 echo "devcontainer [${DEV_CONTAINER_NAME}] already exists; exec'ing into it"
    exec_existing "${1:-"${PWD}"}"
  else
    build_and_run "${1:-"${PWD}"}"
  fi
}

main "$@"
